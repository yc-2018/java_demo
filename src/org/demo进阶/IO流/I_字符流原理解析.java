package org.demo进阶.IO流;

public interface I_字符流原理解析 {
    /*创建字符输入流对象
        底层: 关联文件，并自动创建缓冲区 (长度为8192的字节数组)      可以用调试模式打断点运行可以看到数组的    # 字节流是没有缓冲区的

————————————————————————————————————————————读取数据———————————————————————————————————————————————————————————————————
        底层: 1.判断缓冲区中是否有数据可以读取
             2.缓冲区没有数据:就从文件中获取数据，装到缓冲区中，每次尽可能装满缓冲区
                            如果文件中也没有数据了，返回-1
             3.缓冲区有数据：就从缓冲区中读取。
                空参的read方法:一次读取一个字节，遇到中文一次读多个字节，把字节解码并转成十进制返回
                有参的read方法:把读取字节，解码，强转三步合并了，强转之后的字符放到数组中



       FileReader fr = new FileReader("myio\\b.txt");
          fr.read();//会把文件中的数据放到缓冲区当中
        //清空文件
          FileWriter fw = new FileWriter("myio\\b.txt");

        //请问，如果我再次使用fr进行读取
        //会读取到数据吗?

            //会把缓冲区中的数据全部读取完毕
        //正确答案:
        //但是只能读取缓冲区中的数据，文件中剩余的数据无法再次读取

————————————————————————————————————————————写出数据———————————————————————————————————————————————————————————————————
缓冲区：长度为: 8192的字节数组
不会直接写出到数据文件   有三种情况才会
情况1: 装满了
情况2: flush
情况3: close


成员方法                         说明
public void flush()     将缓冲区中的数据，刷新到本地文件中
public void close()     释放资源/关流

flush刷新: 刷新之后，还可以继续往文件中写出数据
close关流:断开通道，无法再往文件中写出数据
        */
}