package org.demo.多态;

public class 啥多态呀 {
    //什么是多态?
        //同类型的对象，表现出的不同形态   or  对象的多种形态。

    //多态的表现形式
        //父类类型 对象名称 = new 子类对象();

    //多态的前提
        //有继承关系/实现关系
        //有父类引用指向子类对象
        //有方法重写

    //多态的好处?
        //使用父类型作为参数，可以接收所有子类对象

    //多态调用成员的特点
        //变量调用:编译看左边，运行也看左边
            //编译看左边:javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译*失败*。
            //运行也看左边: java运行代码的时候，实际获取的就是左边父类中成员变量的值
        //方法调用:编译看左边，运行看右边。
            //编译看左边: javac编译代码的时候，会看左边的父类中有没有这个方法，如果有，编译成功，如果没有编译**失败。
            // 运行看右边: java运行代码的时候，实际上运行的是子类中的方法。
    //理解:
    //Animal a = new Dog();
    //现在用a去调用变量和方法的呀? 是的
    //而a是Animal类型的，所以默认都会从Animal这个类中去找
    //成员变量:在子类的对象中，会把父类的成员变量也继承下的。父: name 子: name
    // 成员方法:如果子类对方法进行了重写，那么在方法表中是会把父类的方法进行覆盖的。


    //多态的优势
    //在多态形式下，右边对象可以实现解耦合，便于扩展和维护。
    // 业务逻辑发生改变时，后续代码无需修改
    //定义方法的时候，使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利。

    //多态的弊端
        //不能调用子类的特有功能
        //报错的原因?    Animal a = new Dog(); 动物这个类没有吃骨头所以编译就报错了
        //当调用成员方法的时候，编译看左边，运行看右边
        //那么在编译的时候会先检查左边的父类中有没有这个方法，如果没有直接报错。
    //解决方案:
        //变回子类类型就可以了（强转）
        //细节: 转换的时候不能瞎转，如果转成其他类的类型，就会报错
        // Cat c = (Cat) a;
        // c.cat抓老鼠();
        //变量名 instanceof 类名     返回布尔值
        //if(a instanceof Dog fDog c = (Dog) a;}else if(a是不是 猫){Cat c = (Cat) a;









}
